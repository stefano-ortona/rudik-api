/**
 * RuDiK 1.0 Async APIs
 * Collection of APIs for inducing declarative rules with RuDiK and few others utility methods for RDF knowledge graphs accesible via a SPARQL endpoint.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: stefano.ortona@meltwater.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package asu.edu.api.model;

import java.util.Objects;
import asu.edu.api.model.RelationPrefix;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;


/**
 * GraphSpecification
 */
@javax.annotation.Generated(value = "class io.swagger.codegen.languages.JavaClientCodegen", date = "2017-11-08T13:58:07.522Z")
public class GraphSpecification   {
  @JsonProperty("id")
  private String id = null;

  /**
   * Name of the knowledge graph to mine rules from. If chosen from known graphs, the mining will happen on the stored graphs. If 'other' is chosen, then an endpoint url must be provided to query the graph.
   */
  public enum NameEnum {
    YAGO("yago"),
    
    DBPEDIA("dbpedia"),
    
    WIKIMETA("wikimeta"),
    
    FREEBASE("freebase"),
    
    OTHER("other");

    private String value;

    NameEnum(String value) {
      this.value = value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static NameEnum fromValue(String text) {
      for (NameEnum b : NameEnum.values()) {
          if (String.valueOf(b.value).equals(text)) {
              return b;
          }
      }
      return null;
    }
  }

  @JsonProperty("name")
  private NameEnum name = null;

  @JsonProperty("endpoint")
  private String endpoint = null;

  @JsonProperty("iri")
  private String iri = null;

  @JsonProperty("prefix")
  private List<RelationPrefix> prefix = new ArrayList<RelationPrefix>();

  @JsonProperty("targetPrefix")
  private String targetPrefix = null;

  @JsonProperty("avoidRelation")
  private List<String> avoidRelation = new ArrayList<String>();

  @JsonProperty("typePrefix")
  private List<String> typePrefix = new ArrayList<String>();

  @JsonProperty("disequalityRelation")
  private Integer disequalityRelation = null;

  @JsonProperty("alpha")
  private Double alpha = null;

  @JsonProperty("beta")
  private Double beta = null;

  @JsonProperty("incomingEdges")
  private Integer incomingEdges = null;

  @JsonProperty("outgoingEdges")
  private Integer outgoingEdges = null;

  @JsonProperty("positiveExamplesLimit")
  private Integer positiveExamplesLimit = null;

  @JsonProperty("negativeExamplesLimit")
  private Integer negativeExamplesLimit = null;

  @JsonProperty("literal")
  private Boolean literal = null;

  public GraphSpecification id(String id) {
    this.id = id;
    return this;
  }

   /**
   * ID for the current graph. Derived from properties of the current mining configuration and graph name. Currently <hash(GraphSpecification)>
   * @return id
  **/
  @ApiModelProperty(example = "null", value = "ID for the current graph. Derived from properties of the current mining configuration and graph name. Currently <hash(GraphSpecification)>")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public GraphSpecification name(NameEnum name) {
    this.name = name;
    return this;
  }

   /**
   * Name of the knowledge graph to mine rules from. If chosen from known graphs, the mining will happen on the stored graphs. If 'other' is chosen, then an endpoint url must be provided to query the graph.
   * @return name
  **/
  @ApiModelProperty(example = "null", required = true, value = "Name of the knowledge graph to mine rules from. If chosen from known graphs, the mining will happen on the stored graphs. If 'other' is chosen, then an endpoint url must be provided to query the graph.")
  public NameEnum getName() {
    return name;
  }

  public void setName(NameEnum name) {
    this.name = name;
  }

  public GraphSpecification endpoint(String endpoint) {
    this.endpoint = endpoint;
    return this;
  }

   /**
   * Sparql endpoint to query the give knowledge graph.
   * @return endpoint
  **/
  @ApiModelProperty(example = "null", value = "Sparql endpoint to query the give knowledge graph.")
  public String getEndpoint() {
    return endpoint;
  }

  public void setEndpoint(String endpoint) {
    this.endpoint = endpoint;
  }

  public GraphSpecification iri(String iri) {
    this.iri = iri;
    return this;
  }

   /**
   * Graph iri.
   * @return iri
  **/
  @ApiModelProperty(example = "null", value = "Graph iri.")
  public String getIri() {
    return iri;
  }

  public void setIri(String iri) {
    this.iri = iri;
  }

  public GraphSpecification prefix(List<RelationPrefix> prefix) {
    this.prefix = prefix;
    return this;
  }

  public GraphSpecification addPrefixItem(RelationPrefix prefixItem) {
    this.prefix.add(prefixItem);
    return this;
  }

   /**
   * RDF prefixes to be specified when running SPARQL queries.
   * @return prefix
  **/
  @ApiModelProperty(example = "null", value = "RDF prefixes to be specified when running SPARQL queries.")
  public List<RelationPrefix> getPrefix() {
    return prefix;
  }

  public void setPrefix(List<RelationPrefix> prefix) {
    this.prefix = prefix;
  }

  public GraphSpecification targetPrefix(String targetPrefix) {
    this.targetPrefix = targetPrefix;
    return this;
  }

   /**
   * If specified, all relations used in the mining must start with this prefix.
   * @return targetPrefix
  **/
  @ApiModelProperty(example = "null", value = "If specified, all relations used in the mining must start with this prefix.")
  public String getTargetPrefix() {
    return targetPrefix;
  }

  public void setTargetPrefix(String targetPrefix) {
    this.targetPrefix = targetPrefix;
  }

  public GraphSpecification avoidRelation(List<String> avoidRelation) {
    this.avoidRelation = avoidRelation;
    return this;
  }

  public GraphSpecification addAvoidRelationItem(String avoidRelationItem) {
    this.avoidRelation.add(avoidRelationItem);
    return this;
  }

   /**
   * Relations to avoid during the mining.
   * @return avoidRelation
  **/
  @ApiModelProperty(example = "null", value = "Relations to avoid during the mining.")
  public List<String> getAvoidRelation() {
    return avoidRelation;
  }

  public void setAvoidRelation(List<String> avoidRelation) {
    this.avoidRelation = avoidRelation;
  }

  public GraphSpecification typePrefix(List<String> typePrefix) {
    this.typePrefix = typePrefix;
    return this;
  }

  public GraphSpecification addTypePrefixItem(String typePrefixItem) {
    this.typePrefix.add(typePrefixItem);
    return this;
  }

   /**
   * Relation prefixes to be used as type for entities.
   * @return typePrefix
  **/
  @ApiModelProperty(example = "null", value = "Relation prefixes to be used as type for entities.")
  public List<String> getTypePrefix() {
    return typePrefix;
  }

  public void setTypePrefix(List<String> typePrefix) {
    this.typePrefix = typePrefix;
  }

  public GraphSpecification disequalityRelation(Integer disequalityRelation) {
    this.disequalityRelation = disequalityRelation;
    return this;
  }

   /**
   * Specify here the number of type-relations two entities must have in common to be considered of the same type. 0 means all types, while a negative number means two entities will be never considered of the same type.
   * @return disequalityRelation
  **/
  @ApiModelProperty(example = "null", value = "Specify here the number of type-relations two entities must have in common to be considered of the same type. 0 means all types, while a negative number means two entities will be never considered of the same type.")
  public Integer getDisequalityRelation() {
    return disequalityRelation;
  }

  public void setDisequalityRelation(Integer disequalityRelation) {
    this.disequalityRelation = disequalityRelation;
  }

  public GraphSpecification alpha(Double alpha) {
    this.alpha = alpha;
    return this;
  }

   /**
   * Adjust alph to get more rules in output with less accuracy. Alpha can be between 0 and 1, and alpha+beta=1.
   * @return alpha
  **/
  @ApiModelProperty(example = "null", value = "Adjust alph to get more rules in output with less accuracy. Alpha can be between 0 and 1, and alpha+beta=1.")
  public Double getAlpha() {
    return alpha;
  }

  public void setAlpha(Double alpha) {
    this.alpha = alpha;
  }

  public GraphSpecification beta(Double beta) {
    this.beta = beta;
    return this;
  }

   /**
   * Adjust beta to get less rules in output with higher accuracy. Beta can be between 0 and 1, and alpha+beta=1.
   * @return beta
  **/
  @ApiModelProperty(example = "null", value = "Adjust beta to get less rules in output with higher accuracy. Beta can be between 0 and 1, and alpha+beta=1.")
  public Double getBeta() {
    return beta;
  }

  public void setBeta(Double beta) {
    this.beta = beta;
  }

  public GraphSpecification incomingEdges(Integer incomingEdges) {
    this.incomingEdges = incomingEdges;
    return this;
  }

   /**
   * Set the maximum number of incoming edges for an entity during the mining exploration.
   * @return incomingEdges
  **/
  @ApiModelProperty(example = "null", value = "Set the maximum number of incoming edges for an entity during the mining exploration.")
  public Integer getIncomingEdges() {
    return incomingEdges;
  }

  public void setIncomingEdges(Integer incomingEdges) {
    this.incomingEdges = incomingEdges;
  }

  public GraphSpecification outgoingEdges(Integer outgoingEdges) {
    this.outgoingEdges = outgoingEdges;
    return this;
  }

   /**
   * Set the maximum number of outgoing edges for an entity during the mining exploration.
   * @return outgoingEdges
  **/
  @ApiModelProperty(example = "null", value = "Set the maximum number of outgoing edges for an entity during the mining exploration.")
  public Integer getOutgoingEdges() {
    return outgoingEdges;
  }

  public void setOutgoingEdges(Integer outgoingEdges) {
    this.outgoingEdges = outgoingEdges;
  }

  public GraphSpecification positiveExamplesLimit(Integer positiveExamplesLimit) {
    this.positiveExamplesLimit = positiveExamplesLimit;
    return this;
  }

   /**
   * Set the limit for the maximum number of positive examples.
   * @return positiveExamplesLimit
  **/
  @ApiModelProperty(example = "null", value = "Set the limit for the maximum number of positive examples.")
  public Integer getPositiveExamplesLimit() {
    return positiveExamplesLimit;
  }

  public void setPositiveExamplesLimit(Integer positiveExamplesLimit) {
    this.positiveExamplesLimit = positiveExamplesLimit;
  }

  public GraphSpecification negativeExamplesLimit(Integer negativeExamplesLimit) {
    this.negativeExamplesLimit = negativeExamplesLimit;
    return this;
  }

   /**
   * Set the limit for the maximum number of negative examples.
   * @return negativeExamplesLimit
  **/
  @ApiModelProperty(example = "null", value = "Set the limit for the maximum number of negative examples.")
  public Integer getNegativeExamplesLimit() {
    return negativeExamplesLimit;
  }

  public void setNegativeExamplesLimit(Integer negativeExamplesLimit) {
    this.negativeExamplesLimit = negativeExamplesLimit;
  }

  public GraphSpecification literal(Boolean literal) {
    this.literal = literal;
    return this;
  }

   /**
   * Include(true)/exclude(false) literal values from the mining.
   * @return literal
  **/
  @ApiModelProperty(example = "null", value = "Include(true)/exclude(false) literal values from the mining.")
  public Boolean getLiteral() {
    return literal;
  }

  public void setLiteral(Boolean literal) {
    this.literal = literal;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    GraphSpecification graphSpecification = (GraphSpecification) o;
    return Objects.equals(this.id, graphSpecification.id) &&
        Objects.equals(this.name, graphSpecification.name) &&
        Objects.equals(this.endpoint, graphSpecification.endpoint) &&
        Objects.equals(this.iri, graphSpecification.iri) &&
        Objects.equals(this.prefix, graphSpecification.prefix) &&
        Objects.equals(this.targetPrefix, graphSpecification.targetPrefix) &&
        Objects.equals(this.avoidRelation, graphSpecification.avoidRelation) &&
        Objects.equals(this.typePrefix, graphSpecification.typePrefix) &&
        Objects.equals(this.disequalityRelation, graphSpecification.disequalityRelation) &&
        Objects.equals(this.alpha, graphSpecification.alpha) &&
        Objects.equals(this.beta, graphSpecification.beta) &&
        Objects.equals(this.incomingEdges, graphSpecification.incomingEdges) &&
        Objects.equals(this.outgoingEdges, graphSpecification.outgoingEdges) &&
        Objects.equals(this.positiveExamplesLimit, graphSpecification.positiveExamplesLimit) &&
        Objects.equals(this.negativeExamplesLimit, graphSpecification.negativeExamplesLimit) &&
        Objects.equals(this.literal, graphSpecification.literal);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, endpoint, iri, prefix, targetPrefix, avoidRelation, typePrefix, disequalityRelation, alpha, beta, incomingEdges, outgoingEdges, positiveExamplesLimit, negativeExamplesLimit, literal);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class GraphSpecification {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    endpoint: ").append(toIndentedString(endpoint)).append("\n");
    sb.append("    iri: ").append(toIndentedString(iri)).append("\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    targetPrefix: ").append(toIndentedString(targetPrefix)).append("\n");
    sb.append("    avoidRelation: ").append(toIndentedString(avoidRelation)).append("\n");
    sb.append("    typePrefix: ").append(toIndentedString(typePrefix)).append("\n");
    sb.append("    disequalityRelation: ").append(toIndentedString(disequalityRelation)).append("\n");
    sb.append("    alpha: ").append(toIndentedString(alpha)).append("\n");
    sb.append("    beta: ").append(toIndentedString(beta)).append("\n");
    sb.append("    incomingEdges: ").append(toIndentedString(incomingEdges)).append("\n");
    sb.append("    outgoingEdges: ").append(toIndentedString(outgoingEdges)).append("\n");
    sb.append("    positiveExamplesLimit: ").append(toIndentedString(positiveExamplesLimit)).append("\n");
    sb.append("    negativeExamplesLimit: ").append(toIndentedString(negativeExamplesLimit)).append("\n");
    sb.append("    literal: ").append(toIndentedString(literal)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

